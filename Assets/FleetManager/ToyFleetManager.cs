using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

/// <summary>
/// Represents a navigation task between two world targets,
/// including the computed path and task metadata.
/// </summary>
[Serializable]
public struct TaskData
{
    /// <summary>Start location component (uses transform.position).</summary>
    public Component TargetA;

    /// <summary>End location component (uses transform.position).</summary>
    public Component TargetB;

    /// <summary>Segmented path waypoints generated by NavMeshPathUtility.</summary>
    public Vector3[] Path;

    /// <summary>Task priority (higher = more important).</summary>
    public int Priority;

    /// <summary>Estimated time to complete the task in seconds.</summary>
    public float TimeToComplete;

    public TaskData(Component targetA, Component targetB, int priority = 0)
    {
        TargetA = targetA;
        TargetB = targetB;
        Path = null;
        Priority = priority;
        TimeToComplete = 0f;
    }
}

/// <summary>
/// ToyFleetManager (minimal):
/// - Holds robotic + human transporter lists
/// - Holds Locations dictionary: code -> LocationData
/// - Subscribes to SequencerSubSys.NewTask and collects all fired tasks
/// - Builds segmented NavMesh path via NavMeshPathUtility, stores into TaskData
/// - Chooses best transporter (ETA w/ reposition) and assigns (adds estimate to queue)
/// </summary>
public sealed class ToyFleetManager : MonoBehaviour
{
    public static ToyFleetManager I { get; private set; }

    [Header("Wiring")]
    [Tooltip("If null, will use SequencerSubSys.I")]
    [SerializeField] private SequencerSubSys sequencer;

    [Tooltip("If null, will use NavMeshPathUtility.I")]
    [SerializeField] private NavMeshPathUtility nav;

    [Header("Transporters")]
    [SerializeField] public List<PatientTransporter> RoboticTransporters = new();
    [SerializeField] public List<PatientTransporter> HumanTransporters = new();

    [Header("Locations")]
    [Tooltip("Runtime registry: location code -> LocationData")]
    [SerializeField] private bool alsoPopulateFromInspectorList = true;

    [Tooltip("Optional: prefill these in Inspector. They will be registered into Locations on Start.")]
    [SerializeField] private List<LocationData> inspectorLocations = new();

    /// <summary>Runtime registry: location code -> LocationData</summary>
    public readonly Dictionary<string, LocationData> Locations = new();

    [Header("Robotic Compatibility Rules")]
    [Tooltip("If priority EXACTLY matches any entry here (case-sensitive), robots are disallowed.")]
    [SerializeField] private List<string> roboticDisallowedPrioritiesExact = new() { "Critical", "STAT", "Stat" };

    [Tooltip("If priority CONTAINS any of these tags (case-insensitive), robots are disallowed.")]
    [SerializeField] private List<string> roboticDisallowedPriorityTags = new() { "ICU", "ISO", "BARI" };

    [Header("NavMesh Segmentation")]
    [Min(0.1f)]
    [SerializeField] private float stepMeters = 2f;

    [SerializeField] private bool sampleToNavMesh = true;
    [SerializeField] private float sampleRadius = 2f;
    [SerializeField] private int areaMask = NavMesh.AllAreas;

    [Header("Debug")]
    [SerializeField] private bool logAssignments = true;
    [SerializeField] private bool logRejectedTasks = true;

    // ------------------------------------------------------------
    // Collected tasks (everything that fires off)
    // ------------------------------------------------------------

    [Serializable]
    public struct TaskRecord
    {
        public string TaskId;
        public string FromCode;
        public string ToCode;
        public string PriorityText;

        public bool RoboticCompatible;

        public TaskData Data;

        public PatientTransporter AssignedTransporter; // null if unassigned
        public bool Assigned;
    }

    [SerializeField] private List<TaskRecord> receivedTasks = new();
    public IReadOnlyList<TaskRecord> ReceivedTasks => receivedTasks;

    // ------------------------------------------------------------
    // Unity lifecycle
    // ------------------------------------------------------------

    private void Awake()
    {
        if (I != null && I != this)
        {
            Destroy(gameObject);
            return;
        }
        I = this;
    }

    private void Start()
    {
        if (sequencer == null) sequencer = SequencerSubSys.I;
        if (nav == null) nav = NavMeshPathUtility.I;

        DedupTransporters(RoboticTransporters);
        DedupTransporters(HumanTransporters);

        if (alsoPopulateFromInspectorList)
            RegisterInspectorLocations();
    }

    private void OnEnable()
    {
        if (sequencer == null) sequencer = SequencerSubSys.I;

        if (sequencer != null)
            sequencer.NewTask += OnNewTask;
        else if (logRejectedTasks)
            Debug.LogWarning("[ToyFleetManager] SequencerSubSys not found; cannot subscribe to NewTask.");
    }

    private void OnDisable()
    {
        if (sequencer != null)
            sequencer.NewTask -= OnNewTask;
    }

    private void OnDestroy()
    {
        if (I == this) I = null;
    }

    // ------------------------------------------------------------
    // Registration API (called by LocationData, spawners, etc.)
    // ------------------------------------------------------------

    public void AddLocation(LocationData location)
    {
        if (location == null) return;

        string code = location.GetLocationCodeName();
        if (string.IsNullOrWhiteSpace(code))
        {
            if (logRejectedTasks)
                Debug.LogWarning($"[ToyFleetManager] Location '{location.name}' has empty locationCodeName.");
            return;
        }

        if (Locations.TryGetValue(code, out var existing) && existing != null && existing != location)
        {
            if (logRejectedTasks)
                Debug.LogWarning($"[ToyFleetManager] Duplicate location code '{code}'. Keeping '{existing.name}', ignoring '{location.name}'.");
            return;
        }

        Locations[code] = location;
    }

    public void AddRoboticTransporter(PatientTransporter transporter)
    {
        if (transporter == null) return;
        if (!RoboticTransporters.Contains(transporter))
            RoboticTransporters.Add(transporter);
    }

    public void AddHumanTransporter(PatientTransporter transporter)
    {
        if (transporter == null) return;
        if (!HumanTransporters.Contains(transporter))
            HumanTransporters.Add(transporter);
    }

    // ------------------------------------------------------------
    // Core: receive tasks
    // ------------------------------------------------------------

    private void OnNewTask(string taskId, string fromArea, string toArea, string priorityText)
    {
        if (nav == null) nav = NavMeshPathUtility.I;

        // Record shell (we always collect the event even if we can’t compute/assign)
        TaskRecord record = new TaskRecord
        {
            TaskId = taskId,
            FromCode = fromArea,
            ToCode = toArea,
            PriorityText = priorityText,
            RoboticCompatible = IsRoboticCompatible(priorityText),
            Data = default,
            AssignedTransporter = null,
            Assigned = false
        };

        // Validate nav
        if (nav == null)
        {
            if (logRejectedTasks)
                Debug.LogWarning($"[ToyFleetManager] Task {taskId}: NavMeshPathUtility not found.");
            receivedTasks.Add(record);
            return;
        }

        // Resolve locations
        if (!Locations.TryGetValue(fromArea, out var fromLoc) || fromLoc == null)
        {
            if (logRejectedTasks)
                Debug.LogWarning($"[ToyFleetManager] Task {taskId}: Unknown FROM location '{fromArea}'.");
            receivedTasks.Add(record);
            return;
        }

        if (!Locations.TryGetValue(toArea, out var toLoc) || toLoc == null)
        {
            if (logRejectedTasks)
                Debug.LogWarning($"[ToyFleetManager] Task {taskId}: Unknown TO location '{toArea}'.");
            receivedTasks.Add(record);
            return;
        }

        // Resolve target objects
        GameObject fromTarget = fromLoc.GetTargetObject();
        GameObject toTarget = toLoc.GetTargetObject();

        if (fromTarget == null || toTarget == null)
        {
            if (logRejectedTasks)
                Debug.LogWarning($"[ToyFleetManager] Task {taskId}: Missing targetObject on LocationData (from/to).");
            receivedTasks.Add(record);
            return;
        }

        Vector3 startPos = fromTarget.transform.position;
        Vector3 endPos = toTarget.transform.position;

        // Build segmented path + distance
        if (!nav.TryGetSegmentedPath(
                startPos,
                endPos,
                out Vector3[] waypoints,
                out float totalDistanceMeters,
                out float floorDiffMeters,
                stepMeters,
                areaMask,
                sampleToNavMesh,
                sampleRadius))
        {
            if (logRejectedTasks)
                Debug.LogWarning($"[ToyFleetManager] Task {taskId}: No complete segmented NavMesh path from '{fromArea}' to '{toArea}'.");
            receivedTasks.Add(record);
            return;
        }

        // Fill TaskData
        // NOTE: TaskData.Priority is int. If you want strict mapping from priorityText -> int, edit ParsePriorityToInt().
        int priorityInt = ParsePriorityToInt(priorityText);

        TaskData data = new TaskData(fromLoc, toLoc, priorityInt)
        {
            Path = waypoints,
            // TimeToComplete will be filled after choosing a transporter
            TimeToComplete = 0f
        };

        record.Data = data;

        // Choose transporter set based on robotic compatibility
        bool canUseRobots = record.RoboticCompatible;
        PatientTransporter best = null;
        float bestEta = float.PositiveInfinity;

        if (canUseRobots)
        {
            EvaluateBestTransporter(RoboticTransporters, startPos, endPos, ref best, ref bestEta);
            EvaluateBestTransporter(HumanTransporters, startPos, endPos, ref best, ref bestEta);
        }
        else
        {
            EvaluateBestTransporter(HumanTransporters, startPos, endPos, ref best, ref bestEta);
        }

        if (best == null || float.IsInfinity(bestEta) || float.IsNaN(bestEta))
        {
            // Still collect event; just unassigned
            receivedTasks.Add(record);
            if (logRejectedTasks)
                Debug.LogWarning($"[ToyFleetManager] Task {taskId}: No valid transporter ETA found (roboticCompatible={canUseRobots}).");
            return;
        }

        // Commit assignment: add estimate to the transporter’s queue
        bool queued = best.AddTaskEstimateToQueueWithReposition(startPos, endPos, nav, areaMask);
        if (!queued)
        {
            // We found an ETA but couldn’t commit queue update; still collect
            receivedTasks.Add(record);
            if (logRejectedTasks)
                Debug.LogWarning($"[ToyFleetManager] Task {taskId}: Best transporter '{best.name}' could not queue task.");
            return;
        }

        // Store final
        data.TimeToComplete = bestEta;
        record.Data = data;
        record.AssignedTransporter = best;
        record.Assigned = true;

        receivedTasks.Add(record);

        if (logAssignments)
        {
            Debug.Log(
                $"[ToyFleetManager] Assigned Task {taskId} ({fromArea}->{toArea}, '{priorityText}', robotOK={canUseRobots}) " +
                $"to '{best.name}' ETA={bestEta:0.00}s | dist={totalDistanceMeters:0.0}m floorΔ={floorDiffMeters:0.0}m waypoints={waypoints.Length}"
            );
        }
    }

    // ------------------------------------------------------------
    // Selection helpers
    // ------------------------------------------------------------

    private void EvaluateBestTransporter(
        List<PatientTransporter> candidates,
        Vector3 newStartWorld,
        Vector3 newEndWorld,
        ref PatientTransporter best,
        ref float bestEta)
    {
        if (candidates == null || candidates.Count == 0) return;

        for (int i = 0; i < candidates.Count; i++)
        {
            var t = candidates[i];
            if (t == null) continue;

            float eta = t.CalculateEstimatedTimeToCompleteWithReposition(newStartWorld, newEndWorld, nav, areaMask);
            if (float.IsNaN(eta) || float.IsInfinity(eta)) continue;

            if (eta < bestEta)
            {
                bestEta = eta;
                best = t;
            }
        }
    }

    private bool IsRoboticCompatible(string priorityText)
    {
        // Exact disallow list (case-sensitive, as requested earlier)
        if (!string.IsNullOrEmpty(priorityText) && roboticDisallowedPrioritiesExact != null)
        {
            for (int i = 0; i < roboticDisallowedPrioritiesExact.Count; i++)
            {
                if (string.Equals(priorityText, roboticDisallowedPrioritiesExact[i], StringComparison.Ordinal))
                    return false;
            }
        }

        // Tag-based disallow (case-insensitive contains)
        if (!string.IsNullOrEmpty(priorityText) && roboticDisallowedPriorityTags != null)
        {
            string p = priorityText.ToLowerInvariant();
            for (int i = 0; i < roboticDisallowedPriorityTags.Count; i++)
            {
                string tag = roboticDisallowedPriorityTags[i];
                if (string.IsNullOrWhiteSpace(tag)) continue;

                if (p.Contains(tag.ToLowerInvariant()))
                    return false;
            }
        }

        return true;
    }

    private int ParsePriorityToInt(string priorityText)
    {
        // Simple default mapping:
        // - if it contains a number, parse it
        // - else: STAT/Critical => 100, else 0
        if (string.IsNullOrWhiteSpace(priorityText))
            return 0;

        // try parse full string
        if (int.TryParse(priorityText.Trim(), out int n))
            return n;

        string p = priorityText.ToLowerInvariant();
        if (p.Contains("stat")) return 100;
        if (p.Contains("critical")) return 100;
        if (p.Contains("high")) return 50;
        if (p.Contains("normal")) return 10;
        if (p.Contains("low")) return 1;

        return 0;
    }

    private void RegisterInspectorLocations()
    {
        if (inspectorLocations == null) return;

        for (int i = 0; i < inspectorLocations.Count; i++)
        {
            var loc = inspectorLocations[i];
            if (loc == null) continue;
            AddLocation(loc);
        }
    }

    private static void DedupTransporters(List<PatientTransporter> list)
    {
        if (list == null) return;

        var set = new HashSet<PatientTransporter>();
        for (int i = list.Count - 1; i >= 0; i--)
        {
            var t = list[i];
            if (t == null || !set.Add(t))
                list.RemoveAt(i);
        }
    }
}
